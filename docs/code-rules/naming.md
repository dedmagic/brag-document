# Правила именования программных объектов

## Раздел 1. Общие правила именования программных объектов {#chapter1}

Относятся ко всем именам: методов, локальных переменных, классов, свойств, параметров методов и т.д.

### 1.1 Самое главное правило: имена не должны врать

**Пример 1:**

```csharp
var persons = GetPersonByDepartment(departmentId);
```

Врёт либо имя переменной, либо имя метода, т.к. в левой части множественное число, в правой – единственное.

**Пример 2:**

```csharp
var a = …
var b = …
void SetA(out a, out b);
```

Имя метода врёт, т.к. судя по нему, в методе устанавливается только значение переменной `a`, на самом деле – еще и переменной `b`.

### 1.2 Самое основное правило: имена всех объектов берутся из предметной области и только оттуда

**Следствие 1.** Запрещено в качестве имен или частей имен использовать абстрактные термины, такие, как:

* item
* element
* data
* datum
* key
* value
* text
* my
* и т.д.

Если, конечно, такой термин не используется в данной конкретно предметной области.

**Следствие 2.** Запрещено в именах использовать номера, если это не продиктовано предметной областью.

Пример того, как нельзя:

```csharp
private void Copy(…)
…

private void Copy2(…)
…
```

**Следствие 3.** Запрещено использовать в именах сокращения, кроме взятых из предметной области или общепринятых, т.е. понятных ЛЮБОМУ разработчику с первого взгляда, например, `max`, `min`, `sum` и т.д.

Примечание: использование сокращений из предметной области всячески приветствуется.

**Следствие 4 (архиважное!).** Запрещено в имена «зашивать» тип данных или детали реализации.

**Пример 1:**

```csharp
Document.SignedXml
```

так – неправильно,

```csharp
Document.SignedContent
```

а вот так – правильно.

**Пример 2:**

```csharp
foreach (var key in Persons /* это dictionary */)
```

– неправильно;

```csharp
foreach (var person in Persons /* это dictionary */)
```

– правильно.

### 1.3 Правило: имя должно полностью отражать смысл и назначение программного объекта, т.е. после прочтения этого имени не должно остаться никаких вопросов

**Пример.**

```csharp
void Copy()…
```

Что здесь копируется? Куда? Откуда? и т.д.

**Глобальное примечание:** все правила относятся и к локальным переменным лямбда-выражений, с тем исключением, что для них допускается сокращение до одной буквы для каждого слова полного имени.

**Пример 1.**

```csharp
… Persons.Where(e => e.Id == personId) …
```

– неправильно;

```csharp
… Persons.Where(p => p.Id == personId) …
```

– правильно.

**Пример 2.**

```csharp
… DocumentVersions.Where(d => d.CreateDate < someDate)
```

– неправильно

```csharp
… DocumentVersions.Where(dv => dv.CreateDate < someDate)
```

– правильно.

### 1.4 Правило: должно соблюдаться единообразие

Например, если в рамках кодовой базы «статус» именуется как «state», то запрещено использовать термин «status».

### 1.5 Правило минимализма

Если есть несколько равнозначных в семантическом плане имён, необходимо использовать то из них, которое имеет минимальную длину (длина измеряется в **количестве слов**).

### 1.6 Простое правило. Имена методов должны начинаться с глагола

А имена методов, возвращающих логическое значение, должны начинаться с глагола-вопроса (`Is` – «является», `Has` – «имеет» и т.д.).

**Примеры:**

```csharp
private List<Indicators> IndicatorsByPeriod(…)
```

– неправильно;

```csharp
private List<Indicators> GetIndicatorsByPeriod(…)
```

– правильно.

```csharp
public bool SignedDocument (…)
```

– неправильно;

```csharp
public bool IsDocumentSigned(…)
```

– правильно.


После глагола должно идти наименование объекта, к которому применяется действие.

**Примеры:**

```csharp
private List<Indicators> GetByPeriod(…)
```

– неправильно;

```csharp
private List<Indicators> GetIndicators(…)
```

– правильно.

```csharp
private List<Indicators> GetIndicatorsByPeriod(…)
```

– правильно.

## Раздел 2. Правила именования программных объектов проекта ProjectA

1. При выборе имени для программного объекта (переменной, метода, типа и т.д.) следует руководствоваться [Общими правилами именования программных объектов](#chapter1).

2. Наименования приватных полей классов должны начинаться с нижнего подчеркивания и соответствовать стилю `camelCase`. Наименование констант является исключением и должно соответствовать стилю `UPPER_CASE`.

```csharp
public class SomeClass
{
    private string _privateField;
    private const int PRIVATE_CONST = 100500;

    public string PublicField;    
}
```

3. Если для различения типов требуется использовать префикс, ссылающийся на уровень приложения, то этот префикс необходимо записывать заглавными буквами: `DAL`, `BLL`, `WEB`.

```csharp
DAL.Program - тип, определённый на уровне доступа к данным

BLL.Program - тип, определённый на уровне бизнес-логики

WEB.Program - тип, определённый на уровне представления (в веб-проекте)
```

4. Имена логических переменных, логических констант, методов, возвращающих логическое значение, должны начинаться с одного из следующих префиксов: `Is`, `Has`, `Should`, `Can`. Для методов также допускается префикс `Try`.

5. Имена namespace-ов должны иметь следующую структуру: первая часть – имя проекта, вторая часть – имя модуля подсистемы (subdomain), далее – на усмотрение разработчиков.

6. Имена методов репозиториев должны формироваться согласно следующим шаблонам:

| Назначение метода | Шаблон имени | Область применимости метода | Примеры |
|-------|-------|-------|-------|
| Получение сущности | `Get…` | Сущность или набор | `GetDocument`, `GetDocuments` |
| Получение набора всех сущностей (без отбора) | `GetAll…` | Набор | `GetAllDocuments` |
| Установка одного или нескольких свойств сущности | `Set…` с указанием имени свойства / имен свойств | Сущность или набор | `SetPeriod(IEnumerable<DAL.FinGrbsDocument> documents, int periodId)` |
| Установка значений всех свойств сущности | `Update…` | Сущность | `UpdateIndicatorHistory` |
| Создание новой сущности | `Create…` | Сущность или набор | `CreateDocument` |
| Создание новой сущности путём копирования существующей | `Create…Copy` | Сущность или набор | `CreateIndicatorHistoryCopy` |
| Удаление сущности | `Remove…` | Сущность или набор | `RemoveCalculationValues` |
| Фильтрация набора сущностей по какому-либо критерию | `FilterBy...` с указанием критерия сортировки | Набор | `FilterByGrbses` |
| Сохранение сущности | `Save...` | Сущность или набор | `SaveDocument`, `SaveCalculationValues` |
| Сохранение всех имеющихся на данный момент изменений (обертка для `SaveChanges` контекста EF) | `SaveAllChanges` | Вселенная | `SaveAllChanges` |
| Логические методы – согласно основному правилу, т.е. `Is...`, `Has...` и т.д. |  | Сущность или набор | `HasSegmentsInPeriod`, `IsUnitExists` |

Методы, изменяющие состояние системы (`Set`, `Update`, `Remove`, `Save`) не должны возвращать никаких значений (т.е. в качестве типа возвращаемого значения должно быть указано `void`).

7. Имя `ViewModel` (модель представления) допустимо сокращать до аббревиатуры `vm` или `Vm` (регистр зависит от контекста).

8. Классы, папки и подсистемы, областью ответственности которых является долговременное хранение данных, должны в имени для обозначения этой ответственности использовать термин `Persistence`.

9. Если программная конструкция (класс, метод, переменная, константа, ...) используется для реализации "костыля", допустимо добавлять к имени этой конструкции постфикс `Hack`.

10. Запрещается использование множественности в наименованиях типов-перечислений за исключением случаев, когда тип-перечисление используется для представления битовых полей.
