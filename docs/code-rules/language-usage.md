# Использование языковых конструкций

1. Не допускается проглатывание исключений, т.е. пустой `catch`.

2. Комментарии в коде запрещены. Исключения:
    1. Автор комментария может обосновать его необходимость.
    2. Для членов перечислений (Enum) допускаются XML-комментарии.
    3. Допустимо комментировать детали реализации регулярных выражений.

3. Методы `First()` и `FirstOrDefault()` допустимо использовать, только если в запросе есть сортировка.  
В случае, если необходимо получить значение свойства, совпадающее у всех элементов коллекции, необходимо использовать метод `GetOneAtAll()` из `CommonLib`. Метод `GetAny()` для этих целей использовать запрещается.

4. Запрещено использовать инициализаторы при создании объектов. Непустые объекты можно создавать только через вызов конструктора с параметрами, конструктор по умолчанию можно использовать только для создания "пустых" объектов, т.е. свойства/поля которых не требуют немедленного заполнения.

5. Для сцепления строк необходимо применять интерполяцию, использование конкатенации не допускается. Исключение: если строковый литерал сам по себе превышает допустимую длину строки кода, его можно разбить на части с помощью конкатенации.

6. При объявлении переменной обязательно использование служебного слова `var`.

7. Использование `List` более предпочтительно, чем `Array`. В том числе при приведении типа к `IEnumerable`.

8. При использовании Entity Framework, в случае если данные запроса нужны только для чтения, следует использовать метод `AsNoTracking()`. В случае, если метод возвращает коллекцию моделей Entity Framework, полученную с использованием `AsNoTracking()`, то и название метода должно завершаться словосочетанием `AsNoTracking`. Например: `GetKbkBySomeAttributeAsNoTracking()`.

9. Не допускается использование имен классов стандартной библиотеки, для которых есть псевдонимы: `System.String` – `string`, `System.Int32` – `int` и т.д. Таким образом, например, запись `string.Empty` допустима, а `String.Empty` – нет.

10. Метод должен иметь максимально специфичный тип возвращаемого значения и максимально обобщенные типы аргументов. Исключение – конструкторы объектов, в них тип параметра должен совпадать с типом инициализируемого поля.

11. Запрещено прямое заполнение полей в нескольких конструкторах. Должен быть один основной (всеобъемлющий, catch-all), в который все значения полей передаются как отдельные параметры и в котором происходит инициализация полей, все остальные конструкторы должны вызывать его через this.

12. Запрещено использование в конструкторах необязательных параметров.

13. Рекомендуется по возможности избегать использования отрицательных условий, т.е., например,

```csharp
if (Person == null)
```

является более предпочтительной записью, чем

```csharp
if (!Person.HasValue)
```

Не стоит следовать этой рекомендации, если это приводит к ухудшению структуры кода, например, к увеличению количества уровней вложенности.

14. Вместо записи `default(тип)` следует использовать запись `default`, т.е. без указания типа.

15. Запрещено использовать т.н. "магические константы", т.е. литералы (неименованные константы), смысл которых не ясен из контекста. Эти магические константы необходимо заменять на именованные константы.

16. Для свойств классов, являющихся коллекциями, необходимо использовать тип `List`.

17. Запрещено использование метода GetHashCode(), как потенциально опасного. См. "Предупреждение" в [документации Microsoft](https://docs.microsoft.com/ru-ru/dotnet/api/system.object.gethashcode?view=netframework-4.8).
